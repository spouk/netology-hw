# Домашнее задание к занятию "12.5. «Индексы»" - `Мартыненко Алексей`


### Задание 1
Напишите запрос к учебной базе данных, который вернёт процентное отношение общего размера всех индексов к общему размеру всех таблиц.
```sql92
select  (sum(INDEX_LENGTH)/sum(DATA_LENGTH))*100 as 'procent'
from information_schema.TABLES
where TABLE_SCHEMA = 'sakila'
and lower(TABLE_TYPE) = 'base table'

```

### Задание 2
Выполните explain analyze следующего запроса:
```sql92
select distinct concat(c.last_name, ' ', c.first_name), sum(p.amount) over (partition by c.customer_id, f.title)
from payment p, rental r, customer c, inventory i, film f
where date(p.payment_date) = '2005-07-30' and p.payment_date = r.rental_date and r.customer_id = c.customer_id and i.inventory_id = r.inventory_id
```
перечислите узкие места;
    подключение таблиц в виде перечисляемого списка дает полную сумму длины каждой таблицы к обработке каждого условия, т.к. происходит   table scan
      и в итоге получается, что субд будет использовать самый неоптимальный алгоритм по выборке time table scan (+payment +rental +customer +inventory +film) = последовательный поиск среди суммы всех записей всех таблиц
    
    
оптимизируйте запрос: внесите корректировки по использованию операторов, при необходимости добавьте индексы.
```sql92
select v.names, sum(v.amm)
from (select distinct concat(c.last_name, ' ', c.first_name)                   as names,
                      sum(p.amount) over (partition by c.customer_id, f.title) as amm
      from payment p
               left join rental r on r.rental_date = p.payment_date
               left join customer c on c.customer_id = r.customer_id
               left join inventory i on i.inventory_id = r.inventory_id
               left join film f on f.film_id = i.film_id
      where date(p.payment_date) = '2005-07-30') as v
group by v.names
order by v.names
```

Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.

### Задание 3*
Самостоятельно изучите, какие типы индексов используются в PostgreSQL. Перечислите те индексы, которые используются в PostgreSQL, а в MySQL — нет.

Приведите ответ в свободной форме.


Bitmap index –
метод битовых индексов заключается в создании отдельных битовых карт (последовательность 0 и 1)
для каждого возможного значения столбца,
где каждому биту соответствует строка с индексируемым значением,
а его значение равное 1 означает, что запись,
соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.



Partial index — это индекс, построенный на части таблицы,
удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.


Function based index Самим же гибким типом индексов являются функциональные индексы, то есть индексы, ключи которых хранят
результат пользовательских функций. Функциональные индексы часто строятся для полей,
значения которых проходят предварительную обработку перед сравнением в команде SQL.


GiST и SP-GiST - тип индексации для данных, представляющих собой к примеру математические координаты геометрической фигура, или
гео-координаты

GIN - "индекс для массивов", в которых есть доступность получения значения ячейки по индексу

BRIN  - индекс, работает с диапазонами блоков (или «диапазонами страниц»).
Блок-диапазон — это группа физически смежных страниц в таблице;
для каждого диапазона блоков некоторая сводная информация хранится в индексе.



