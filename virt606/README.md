# Домашнее задание к занятию "6.6 «Troubleshooting» `Мартыненко Алексей`

### Задача 1
```html
 Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB. 
```

> Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её
нужно прервать.

Вы как инженер поддержки решили произвести эту операцию:

> напишите список операций, которые вы будете производить для остановки запроса пользователя;
```json
# поиск  запросов, по заданным условиям поиска,  по всему пулу запросов в текущий момент времени по субд

db.currentOp(
  {
    "active" : true,
    "secs_running" : { "$gt" : 3*60 },
  }
)
# принудительное прекращение обработки `долгоиграющего` запроса(ов), в контексте задачи - запроса
# в выдаче предыдущего запроса будет получена выдача длинных запросов, в nested-ответа,будут указаны соответствующие 
# `"opid" : <number>` используя которые можно принудительно прекратить запрос

db.killOp(ipid)

```


> предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.
+ постановка на мониторинг с алертами по заданым критериям по согласованию с разрабами учитывая какие базы крутятся и средняя длительность выполняемых запросов, все что будет больше или равно подпадает под алертинг
+ включения соответствующего уровня логгирования `db.setLogLevel()`
+ провести анализ на количество записей в таблицах, по которым вылетают алерты, выявить необходимость в добавлении индексов по столбцам + построить их, по которым есть наиболее сильное проседание при выбороке
+ включения профайлинга (встроенных механизмов субд, собирающих подробную статистику по исполняемым запросам) `db.setProfilingLevel(1)` 
+ по запросам, попадающим а алертинг провести работу по составлению  `db.runCommand({ explain:...})` плана запросов


### Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

> Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение
количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается
пропорционально количеству реплик сервиса.
При масштабировании сервиса до N реплик вы увидели, что:
сначала происходит рост отношения записанных значений к истекшим, Redis блокирует операции записи. Как вы думаете, в чём
может быть проблема?

с очень высокой степенью вероятности доступная ,для демона субд, оперативная память - закончилась 
учитывая, что используется TTL, то вероятно механизм актуальности записи ключа имеет конечный фиксированный период,по 
истечении которого ключ "протухает" и его надо вычищать
надо анализировать причины, почему так долго не вычищаются "устаревшие" ключи, вероятно забит кэш просроченными данными


### Задача 3

> Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи
начали жаловаться на ошибки вида:
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

>Какие пути решения этой проблемы вы можете предложить?

есть 2 конечных кода  по данной ошибке субд
(1) CR_SERVER_LOST - ошибка когда клиентская часть не смогла отправить запрос на сервер
(2) CR_SERVER_GONE_ERROR - когда запрос субд получен был, но не был получен ответ клиентом на него
учитывая,что в постановке задачи фигурирует SELECT, сделаю допущение, что имеет место быть вторая группа ошибок 
для исправления ситуации
+ увеличить значение wait_timeout, увеличение зависит от количества и размеров запрашиваемых данных + пропускная способность канала передачи
+ увеличить значение net_read_timeout, увеличение зависит от количества и размеров запрашиваемых данных
+ по конкретному клиентскому запросу провести анализ таблиц(ы) данные из которых запрашиваются, провести оптимизацию этих таблиц в части 
вероятного шардирования , построения индексов 


### Задача 4

> Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с
большим объёмом данных лучше, чем MySQL.

> После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

```shell
postmaster invoked oom-killer
```

> Как вы думаете, что происходит?

процесс субд выбрал все лимиты по оперативной памяти и ядром был запущен oom-killer - ядерный процесс, который 
собирает оценку (oom_score) и на основе нее принимает решение какой процесс "прибить". Основными критериями является 
количество заимствованной оперативной память процессом
Такая ситуация возможно, когда с клиента(ов) поступают неоптимизированные запросы с кучей ненужных джойнов и "пустых"
для конечного результата, выборок, при которых линейно перебирается и выбирается огромное количество данных из бд,
все эти выборки временно размещаются в оперативной памяти  

> Как бы вы решили эту проблему?

+ снял бы "трейс" с использованием динамической трассировки 
+ изучил бы трейс на предмет запросов, что выжирает оперативку 
+ провел изучение таблиц с которых идет выборка , изучил бы план построения запроса, при необходимости провел оптимизационные работы - собрав индексы по "тормозящим" столбцам и прочее
